package transaction

import (
    "context"
    "strings"
    "time"

    "github.com/gofiber/fiber/v2"
    "github.com/google/uuid"
    "github.com/shopspring/decimal"

    "github.com/crypto-wallet/backend/internal/application/dto"
    "github.com/crypto-wallet/backend/internal/domain/entities"
    "github.com/crypto-wallet/backend/internal/domain/repositories"
    domainservices "github.com/crypto-wallet/backend/internal/domain/services"
    "github.com/crypto-wallet/backend/internal/infrastructure/audit"
    "github.com/crypto-wallet/backend/internal/infrastructure/blockchain"
    "github.com/crypto-wallet/backend/pkg/utils"
)

// Service exposes required domain behaviour for transaction workflows.
type Service interface {
    PrepareSend(params domainservices.SendParams) (*domainservices.SendResult, error)
}

// TransactionRepo aliases the domain transaction repository.
type TransactionRepo interface {
    repositories.TransactionRepository
}

// WalletRepo exposes wallet retrieval for transaction workflows.
type WalletRepo interface {
    GetByID(ctx context.Context, id uuid.UUID) (entities.Wallet, error)
}

// LedgerWriter persists ledger entries generated by transaction workflows.
type LedgerWriter interface {
    CreateEntries(ctx context.Context, entries ...*entities.LedgerEntryEntity) error
}

// BlockchainResolver provides blockchain adapters per chain.
type BlockchainResolver interface {
    Resolve(chain entities.Chain) (blockchain.BlockchainAdapter, error)
}

// AuditLogger captures audit events for compliance.
type AuditLogger interface {
    Record(ctx context.Context, entry audit.Entry) error
}

func mapTransaction(tx entities.Transaction) dto.TransactionStatusResponse {
    if tx == nil {
        return dto.TransactionStatusResponse{}
    }
    return dto.NewTransactionStatusResponse(tx)
}

func mapTransactions(items []entities.Transaction) []dto.TransactionStatusResponse {
    result := make([]dto.TransactionStatusResponse, 0, len(items))
    for _, item := range items {
        result = append(result, mapTransaction(item))
    }
    return result
}

func parseDecimal(value string, field string, errs *utils.ValidationErrors) decimal.Decimal {
    trimmed := strings.TrimSpace(value)
    if trimmed == "" {
        errs.Add(field, "is required")
        return decimal.Zero
    }
    dec, err := decimal.NewFromString(trimmed)
    if err != nil {
        errs.Add(field, "must be a valid decimal string")
        return decimal.Zero
    }
    return dec
}

func wrapValidationError(errs utils.ValidationErrors) error {
    if errs.IsEmpty() {
        return nil
    }
    return utils.NewAppError(
        "VALIDATION_ERROR",
        "transaction payload invalid",
        fiber.StatusBadRequest,
        errs,
        map[string]any{"errors": errs},
    )
}

func pointerTime(value time.Time) *time.Time {
    if value.IsZero() {
        return nil
    }
    v := value
    return &v
}
